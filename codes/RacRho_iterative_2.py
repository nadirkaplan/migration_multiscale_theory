'''
Code designed for the long-duration (only store nucleus position every n steps) durotaxis modeling on gradient substrates (set uniform=0; duro=3)
Data in Fig.5A, B can be generated by running the code for multiple times
'''
import math as m
import numpy as np
import matplotlib.pyplot as plt
import User_functions_cellmigration2 as usf
import Traction2 as T
from random import random
from datetime import date
from celluloid import Camera
import pdb

def migration_simulator(uniform, duro, K_sub, gama_sub, Grad, nnum, dd):

    dt = 0.000008 ;  #  step size

    Nsteps = int(83000000) ;  #  time steps > 8e7 
    save_memb_inv = int(90000); # save the membrane coordinates every # steps
    save_nuc_inv = int(300); # save the nucleus coordinates and forces every # steps
    memb_nuc_times = save_memb_inv/save_nuc_inv;
    Step_inv = int(10000);   
    gama_id = np.amax(gama_sub*nnum/16);
    ksub_id = np.amax(K_sub*nnum/16);
    
    Grad_id = np.amax(Grad*nnum/16);
    fname = 'Duro_'+'Uni'+str(uniform)+'_Ksub'+str(round(ksub_id*100)/100)+'_Gama'+str(round(gama_id*100)/100)+'_Grad'+str(round(Grad_id*100)/100)
    savegifname = fname+dd+'.gif'
    
    filetarray=fname+'_tarray_'+dd+'.dat'
    filemembX=fname+'_Xmemb_'+dd+'.dat'
    filemembY=fname+'_Ymemb_'+dd+'.dat'
    filenucX=fname+'_Xnuc_'+dd+'.dat'
    filenucY=fname+'_Ynuc_'+dd+'.dat'

    
    Rcell = float(5.0)  
    R_nuc = float(2.0)
    shift_distx = np.random.randint(5, 195); 
    shift_disty = np.random.randint(160, 201);  

    # define parameters of chemical modeling
    gama_r = float(0.3) # antagonistic effect of Rho to Rac
    gama_rho = float(0.3) # antagonistic effect of Rac to Rho 
    kb_plus = float(0.6)  # 2.4E-1 # Kp+  baseline Rac1 activation coefficient
    kb_minus = float(0.9); # 6.0E-1  # Kb-    baseline Rac1 inactivation coefficient
    kpolar_minus = float(0.0); #  # Kp-
    kapbb_plus = float(0.6);  #  # kap_p+  2.8E-1 # baseline Rho activation rate 
    kapbb_minus = float(0.9); #  # kap_b-  6.0E-1  # baseline Rho inactivation rate
    kap_polar_minus = float(0.0); #   # kap_p-
    beta_r = float(0.3); # 
    beta_rho = float(0.3); # 
    M_plus =  float(0.04); # float(0.1)  # Rac1 membrane association dissociation rates 
    M_minus = float(0.04); # float(0.05/nnum )
    gg_val = float(0.0);  # float(0.08)
    mu_plus = float(0.04); # float(0.1)  # RhoA membrane association dissociation rates 
    mu_minus = float(0.04);  # float(0.05/nnum )
    hh_val = float(0.0);  # float(0.08); 
    D = float(0.010); 
    eta_nuc = float(800);  # pa*s = pn*s/um^2 =1e-6 pn*s/nm^2


    # define parameters of mechanics modeling
    alpha = float(5.0);
    kc = float(120.)
    ks = float(0.25)
    N_M = float(100*16/nnum )  
    fs = float(1 )
    fm = float(2  )  #/fs
    epsilon = float(0.0 )  #/fs
    zeta = float(0.0)
    fc = float(0.50)      #*fs
    fcr = float(1.5)
    v0 = float(0.120)
    V_p = float(0.120 )#average polymerization rate
    fa = 0.0


    N_C0 = float(100*16/nnum ) 
    Ksub_ub = float(100*16/nnum)
    Gsub_ub = float(10*16/nnum)
    Ksub_lb = float(0.001*16/nnum)
    Gsub_lb = float(0.001*16/nnum)
    K_clutch = float(2.)
    fb = float(800.)
    K_memb = float(2.0*nnum/16) #membrane stiffness  pn/um  
    eta_memb = float(0.01)  # #membrane viscoelastic coefficient    pn*s/um
    K_ck = float(20.0*16/nnum) #Microtubules stiffness pn/um   *Rcell
    K_Area = float(0.0) #Area preservation coefficient


    # Dimensionless scale
    XX = 2*np.pi*Rcell;     #um
    TT = XX/v0; #s
    Km0 = 2.0;      #pN/um
    FF = Km0*XX;    #pN

    #Dimesionalize all para
    gama_r_bar = gama_r*TT ;
    gama_rho_bar = gama_rho*TT ;
    beta_r_bar = beta_r*TT ;
    beta_rho_bar = beta_rho*TT ;

    kb_plus_bar = kb_plus*TT ;
    kb_minus_bar = kb_minus*TT ;
    kpolar_minus_bar = kpolar_minus*TT ;
    kap_polar_minus_bar = kap_polar_minus*TT ;
    kapbb_plus_bar = kapbb_plus*TT ;
    kapbb_minus_bar = kapbb_minus*TT ;

    M_plus_bar = M_plus*TT ;
    M_minus_bar = M_minus*TT ;
    mu_plus_bar = mu_plus*TT ;
    mu_minus_bar = mu_minus*TT ;
    D_bar = D/(XX*v0) ;

    Kon_0bar = alpha*TT ;
    epsilon_bar = epsilon*FF*TT;
    zeta_bar = zeta*TT ;
    kc_bar = kc*TT ;
    ks_bar = ks*TT ;
    fc_bar = fc/FF ;
    fs_bar = fs/FF ;
    fm_bar = fm/FF ;
    fcr_bar = fcr/FF ;
    v0_bar = v0*TT/XX ;
    K_clutch_bar = K_clutch/Km0*1e3 ;
    K_memb_bar = K_memb/Km0 ;

    Ksub_ub_bar = Ksub_ub/Km0*1e3 ;
    Gsub_ub_bar = Gsub_ub/(Km0*TT)*1e3 ;
    Ksub_lb_bar = Ksub_lb/Km0*1e3 ;
    Gsub_lb_bar = Gsub_lb/(Km0*TT)*1e3 ;

    K_ck_bar = K_ck/Km0;
    eta_memb_bar = eta_memb/Km0*v0 ;
    eta_nuc_bar = eta_nuc/Km0*v0 ;

    Rcell_bar = Rcell/XX ; 
    R_nuc_bar = R_nuc/XX ; 
    shift_dist_bar1 = shift_distx/XX ; 
    shift_dist_bar2 = shift_disty/XX ; 
    vp_bar = V_p*TT/XX ; 

    K_sub_bar = K_sub/Km0*1e3 ; 
    gama_sub_bar = gama_sub/(Km0*TT)*1e3 ; 
    Grad_bar = Grad/Km0*1e3 ; 

    Ini_Raca = float(0.3)
    Ini_Raci = float(0.2)
    Ini_Rhoa = float(0.3)
    Ini_Rhoi = float(0.2)
    rac_0  = Ini_Raca/nnum
    rho_0  = Ini_Rhoa/nnum
    polar_num = int(nnum/4)

    coords_scale = np.linspace(0.0, 1.0, nnum+1)

    xcell = Rcell_bar*np.cos(2*np.pi*coords_scale[0:nnum])
    ycell = Rcell_bar*np.sin(2*np.pi*coords_scale[0:nnum])
    edge_L0 = np.sqrt(2.*(Rcell_bar**2.)*(1 - np.cos(2*np.pi*coords_scale[1])))
    #eglen_max = edge_L0;

    ''' 
    Pre-define values of chemo-singals 
    ''' 
    Rac_cyto = np.zeros([Nsteps]) 
    F_pro = np.zeros([nnum]); 
    R_len = Rcell_bar*np.ones([nnum]); 

    cycid=1;
    Ini_RacRho = usf.Initialize_RacRho(Ini_Raca, Ini_Raci, Ini_Rhoa, Ini_Rhoi, polar_num, nnum, uniform, cycid);
    rac_an=Ini_RacRho[0];  rac_in=Ini_RacRho[1];
    rho_an=Ini_RacRho[2];  rho_in=Ini_RacRho[3];

    N_C = N_C0 * np.ones(nnum) 
    nc = N_C ; 
    nm = N_M * np.ones(nnum) 
    Rcn =   1- (np.sum(rac_an) + np.sum(rac_in))   #assign value 
    Rhocn = 1- (np.sum(rho_an) + np.sum(rho_in))   #assign value
    Rac_cyto[0] = Rcn 
    Avg_Rac1_mb = np.mean(rac_an)
    Avg_Rhoa_mb = np.mean(rho_an)

    Fsub_val = np.zeros([nnum]);
    #Pre-define mechanical responses
    xnuc_pst = 0.0 + shift_dist_bar1;
    ynuc_pst = 0.0 + shift_dist_bar2;
    xnuc_pst0 = usf.assign_scalar(xnuc_pst);
    ynuc_pst0 = usf.assign_scalar(ynuc_pst);

    xnuc_all = np.zeros([int(Nsteps/save_nuc_inv+10)]);  #Nucleus velocity and position vectors
    xnuc_all[0] = xnuc_pst;
    ynuc_all = np.zeros([int(Nsteps/save_nuc_inv+10)]);
    ynuc_all[0] = ynuc_pst;

    Area = np.zeros([int(Nsteps/save_nuc_inv+10)]);  #Cell areas


    Ro_all = np.zeros([nnum])  #bonded clutch density

    xc_all = np.zeros([nnum]) #displacements of actin
    xs_all = np.zeros([nnum]) #displacements of substrate
    f_all = np.zeros([nnum]) #molecular clutch forces

    Vs = np.zeros([nnum]) #Membrane spreading velocity


    xcoord = np.zeros([nnum+1]);  xcoord[:nnum] = xcell + shift_dist_bar1;   xcoord[nnum] = xcoord[0];
    ycoord = np.zeros([nnum+1]);  ycoord[:nnum] = ycell + shift_dist_bar2;   ycoord[nnum] = ycoord[0];
    xcoord0 = np.zeros([nnum+1]);  xcoord0 = usf.assign_values(xcoord);
    ycoord0 = np.zeros([nnum+1]);  ycoord0 = usf.assign_values(ycoord);
    xcoord_tem = np.zeros([nnum+1]);  xcoord_tem = usf.assign_values(xcoord);
    ycoord_tem = np.zeros([nnum+1]);  ycoord_tem = usf.assign_values(ycoord);
    xcoord_all = np.zeros([nnum+1, int(Nsteps/save_memb_inv+10)]);  
    ycoord_all = np.zeros([nnum+1, int(Nsteps/save_memb_inv+10)]);  
    xcoord_all[:,0] = xcoord;            ycoord_all[:,0] = ycoord;

    memb_step = 0;
    nuc_step = 0;

    nuc_mem_vx = xcoord_all[:nnum,0] - xnuc_all[0];  # direction vectors of every membrane pts 
    nuc_mem_vy = ycoord_all[:nnum,0] - ynuc_all[0];  # direction vectors from nucleus to membrane
    [nm_pts_vx, nm_pts_vy, R_len, Aa] = usf.Normalize_vector(nuc_mem_vx, nuc_mem_vy) #normalized position vectors
    Area[0] = Aa;     Aa0 = Area[0];        

    edge_ang_all = np.zeros([nnum, Step_inv]);   # all edge angles of very time step

    ang_diff_all = np.zeros([nnum]);
    edge_ang_avg = np.zeros([nnum, int(Nsteps/Step_inv)+10]);  # average edge angles for every 'step_inv' steps
    avgang_diff_all = np.zeros([nnum, int(Nsteps/Step_inv)+10]); 

    cr_all = np.zeros([nnum, int(Nsteps/Step_inv)+10]);
    dr_all = np.zeros([nnum, int(Nsteps/Step_inv)+10]);

    Fst_val= np.zeros([nnum]);

    Fstall=np.zeros([nnum]);



    '''
    Calculate and assemble global derivative matrix
    '''
    vec_edges=usf.edge_vectors(xcell, ycell);  #get edge length and direction vectors
    edge_ang=usf.edge_angles(vec_edges, nnum);
    edge_ang_all[:,0] = edge_ang;
    Angle0 = edge_ang_all[0,0];
    edge_len = usf.edge_length(xcell, ycell)
    #edge_len_all[:,0] = edge_len[0]

    tm = float(0.0)
    time = np.zeros([int(Nsteps/save_nuc_inv+10)] )
    RacRho_ini = np.zeros([4*nnum + 2] )
    RacRho_last= np.zeros([4*nnum + 2] )
    RacRho_current= np.zeros([4*nnum + 2])
    RacRho_inputs= np.zeros([4*nnum + 2] )
    Step_inv_no = 0;      steady_step_num = np.zeros([50000]);  


    for i in range(Nsteps-1):
        if i%2000000<1e-3 and i>0:
            print('Nsteps=', i)
            np.savetxt(filetarray, time.transpose(),  fmt='%.6e', delimiter='\t');
            np.savetxt(filenucX, xnuc_all.transpose(),  fmt='%.6e', delimiter='\t');
            np.savetxt(filenucY, ynuc_all.transpose(),  fmt='%.6e', delimiter='\t');

            


        if i%5000000<1e-2 and nuc_step>100000:
            if abs(xnuc_all[nuc_step]- xnuc_all[int(nuc_step-100000)]) < 1e-2:
                exit();

                        
        if i%Step_inv<1e-3 and i>0:
            step_bn=Step_inv_no*Step_inv;   Step_inv_no += 1;   step_en=Step_inv_no*Step_inv-1;
            for nn in range(nnum):
                edge_ang_avg[nn, Step_inv_no] = np.average(edge_ang_all[nn,:]);
            avgang_diff_all[:,Step_inv_no] = (edge_ang_avg[:,Step_inv_no]-edge_ang_avg[:,Step_inv_no-1]);
        
        if i%Step_inv<1e-3 and Step_inv_no>1:
            avgang_diff0 = np.zeros(nnum);
            for ij in range(nnum): 
                avgang_diff0[ij] = np.amax(np.absolute(avgang_diff_all[ij,0:Step_inv_no]));
            avgang_diff = (edge_ang_avg[:,Step_inv_no]-edge_ang_avg[:,Step_inv_no-1]);
            polar_or_contract = (edge_ang_avg[:,Step_inv_no] - Angle0);  # + in contraction; - in protrusion

        tm += dt
        #time[i+1]= tm
    
        if i<1: Rac_cyto_diff = 1;
        else:   Rac_cyto_diff = abs(Rac_cyto[i] - Rac_cyto[i-1]);  #Rac_cyto[i-2]);

        if Rac_cyto_diff < Rac_cyto_tol:       
            Ini_RacRho = usf.Initialize_RacRho(Ini_Raca, Ini_Raci, Ini_Rhoa, Ini_Rhoi, polar_num, nnum, uniform, cycid);

            rac_an = Ini_RacRho[0];   rac_in = Ini_RacRho[1];
            rho_an = Ini_RacRho[2];   rho_in = Ini_RacRho[3];
            Rac_cyto[i] = 1- (np.sum(rac_an) + np.sum(rac_in))   #assign value 

            Rcn =   1- (np.sum(rac_an) + np.sum(rac_in))   #assign value 
            Rhocn = 1- (np.sum(rho_an) + np.sum(rho_in))   #assign value
            steady_step_num[cycid] = i;   cycid += 1;

       

        RacRho_current = usf.Assemble_RacRho(rac_an, rac_in, rho_an, rho_in, Rcn, Rhocn, nnum)
        rac_a = usf.assign_values(rac_an);   rac_i = usf.assign_values(rac_in);
        rho_a = usf.assign_values(rho_an);   rho_i = usf.assign_values(rho_in);
        Rc = usf.assign_scalar(Rcn);         Rhoc = usf.assign_scalar(Rhocn);
        

    
        '''
        Bio-chemical model  ----  update Rac and Rho signaling  
        '''
        tol = 1E-9
        maxiter = 20 
        eps = 1E3*tol 
        iter = int(0) 
        while eps > tol and iter < maxiter:
            iter += 1
            #RacRho_ini = usf.Assemble_RacRho(rac_an, rac_in, rho_an, rho_in, Rcn, Rhocn, nnum);
            K_plus = np.zeros([nnum,3]);    K_minus = np.zeros([nnum]);
            kappa_p = np.zeros([nnum,3]);   kappa_m = np.zeros([nnum]);
            for j in range(nnum):
                rac_aj = rac_a[j];     rac_ij = rac_i[j];
                rho_aj = rho_a[j];     rho_ij = rho_i[j];
                Rj_len = R_len[j];     ncj = nc[j];    nmj = nm[j];
                #angj = edge_ang_all[j,i%Step_inv];
                angj = edge_ang[j];
                ang_diffj = ang_diff_all[j];
                if Step_inv_no<=1:
                    cr = 1.0; dr = 1.0;
                    cr_all[j,Step_inv_no]=cr;   dr_all[j,Step_inv_no]=dr; 
                elif i%Step_inv<1e-3 and Step_inv_no>1:
                    avgang_diff_tol = np.absolute(avgang_diff);
                    avgang_diff0_tol = np.absolute(avgang_diff0);   
                    if avgang_diff_tol[j]<0.3*avgang_diff0_tol[j] and polar_or_contract[j]>0.3*Angle0:
                        coeff_cr=np.absolute(2*ang_diffj)/Angle0;   cr = np.exp(coeff_cr);
                    elif avgang_diff_tol[j]<0.3*avgang_diff0_tol[j] and polar_or_contract[j]<-0.3*Angle0:
                        coeff_dr=np.absolute(2*ang_diffj)/Angle0;   dr = np.exp(coeff_dr);
                    else:
                        cr = 1.0; dr = 1.0;
                    cr_all[j,Step_inv_no]=cr;   dr_all[j,Step_inv_no]=dr; 
                cr = cr_all[j,Step_inv_no];     dr = dr_all[j,Step_inv_no]
                K_plus[j,:]  = usf.Rac1_activation(kb_plus_bar, gama_r_bar, beta_r_bar, rho_aj, rac_aj, rac_0, rho_0, cr, norder = 3.0)
                K_minus[j] = usf.Rac1_inactivation(kb_minus_bar, kpolar_minus_bar, angj, Angle0)
                kappa_p[j,:] = usf.RhoA_activation(kapbb_plus_bar, gama_rho_bar, beta_rho_bar, rac_aj, rho_aj, rac_0, rho_0, dr, norder = 3.0)
                kappa_m[j] = usf.RhoA_inactivation(kapbb_minus_bar, kap_polar_minus_bar, angj, Angle0)
            matrix_res = usf.global_matrix_residue(rho_a, rac_a, rho_i, rac_i, rho_an, rac_an,  \
                     rho_in, rac_in, K_plus, K_minus, kappa_p, kappa_m, M_plus_bar, M_minus_bar, \
                     mu_plus_bar, mu_minus_bar, D_bar, edge_len, Rc, Rhoc, Rcn, Rhocn, nnum, dt ) 
            Delta_RacRho = - np.linalg.solve(matrix_res[0], matrix_res[1])
            eps = np.linalg.norm(Delta_RacRho)
            RacRho_current += Delta_RacRho
            RacRho_inputs = usf.Disassemble_RacRho(RacRho_current, nnum)
            rac_a = RacRho_inputs[0];   rac_i = RacRho_inputs[1];
            rho_a = RacRho_inputs[2];   rho_i = RacRho_inputs[3];
            Rc = RacRho_inputs[4];      Rhoc = RacRho_inputs[5];
        

        for jj in range(nnum):
            rac_an[jj] = rac_a[jj];     rac_in[jj] = rac_i[jj];
            rho_an[jj] = rho_a[jj];     rho_in[jj] = rho_i[jj];        
        Rcn = RacRho_inputs[4];         Rhocn = RacRho_inputs[5];
        Rac_cyto[i+1] = RacRho_inputs[4];   
        if iter >= maxiter-1: print('Cannot converge at step =',i); break


        #update/calculate N_clutch and N_myosin based on chemical signaling
        Avg_Rac1_mb = np.mean(rac_a);  
        Avg_Rhoa_mb = np.mean(rho_a);  
        nc = rac_a/Avg_Rac1_mb*N_C;  
        nm = rho_a/Avg_Rhoa_mb*N_M;   
        Vp = np.minimum(rac_a/Avg_Rac1_mb, 3)*vp_bar;
        nc = np.minimum(nc, 3*N_C);     Vp = np.minimum(Vp, 3*vp_bar);      nm = np.minimum(nm, 3*N_M);   
        nc = np.maximum(nc, 0.3*N_C);   Vp = np.maximum(Vp, 0.3*vp_bar);    nm = np.maximum(nm, 0.3*N_M);

    
    
        '''
        Now introduce mechanics  --- update displacements
        '''
        disp_tol = 1e-3; iteration =0;

        fbond = np.zeros([nnum]);      
        xc0_all = np.zeros([nnum]);    xs0_all = np.zeros([nnum]);
        Ro_all0 = np.zeros([nnum])  #bonded clutch density
        for j in range(nnum):
            xc0_all[j] = xc_all[j];  xs0_all[j] = xs_all[j];
            Ro_all0[j] = Ro_all[j];

        while disp_tol>1e-5 and iteration < 1:
            iteration += 1;
            for j in range(nnum):
                Ro_0 = Ro_all0[j];  xc0 = xc0_all[j];  xs0 = xs0_all[j];
                f = f_all[j];
                #xcj = xcoord_all[j, i];  ycj = ycoord_all[j, i];
                xcj = xcoord[j];   ycj = ycoord[j]; 
                Ro = T.closed_bond_prob(Kon_0bar, epsilon_bar, zeta_bar, ks_bar, kc_bar, fa, fcr_bar, fc_bar, fs_bar, f, Ro_0, dt);
                if Ro < 1e-6:  # or f > fb
                    f =0.; Ro = 0.; 
                    xc = 0.; xs = 0.; 
                else:
                    beta = Ro*nc[j]*K_clutch_bar;      F_stall = nm[j]*fm_bar;       F_p = F_pro[j]; 
                    k_gama = usf.sub_stiff_visco(xcj, ycj, Rcell_bar, K_sub_bar, Grad_bar, gama_sub_bar, \
                                             Ksub_ub_bar, Gsub_ub_bar, Ksub_lb_bar, Gsub_lb_bar, duro);
                    xc_xs=T.update_disps(xs0, xc0, F_stall, F_p, beta, k_gama[0],  v0_bar, k_gama[1], dt);
                    f = K_clutch_bar*(xc_xs[0] - xc_xs[1]); 
                    xc = xc_xs[0]; xs = xc_xs[1]; 
                Ro_all[j] = Ro;  xc_all[j] = xc;  xs_all[j] = xs; 
                Fsub = Ro*nc[j]*f;  
                F_st = Fst_val[j];  
                vf =  T.Retrograde_velocity(F_st, F_stall, v0_bar);
                fbond[j] = f;   Fsub_val[j] = Fsub;
                Fstall[j]= F_stall;
                Vs[j] = Vp[j] - vf
                    
            #update membrane (xcoord_all) shape and outward-direction vector (vec)
            xycoord=usf.coord_direction_update(Vs, xcoord0, ycoord0, nm_pts_vx, nm_pts_vy, dt, nnum);
            xcoord = xycoord[0];    ycoord = xycoord[1]; 
            Force_ck = T.microtubule_force(R_len, K_ck_bar, Rcell_bar);  # calculate cytoskeleton forces
            vec_edges=usf.edge_vectors(xcoord[:nnum], ycoord[:nnum]);
            edge_ang=usf.edge_angles(vec_edges, nnum);   edge_ang_all[:,(i+1)%Step_inv] = edge_ang;
            ang_diff_all= usf.angle_diff(edge_ang, nnum);
        

            Force_Vm=T.membrane_protrusion_fv(vec_edges, K_memb_bar, edge_L0, Force_ck[0],  eta_memb_bar, Vs, nm_pts_vx, nm_pts_vy);
            F_pro=Force_Vm[0];      #F_pro_all[:,i+1]= F_pro;          
            Vm = Force_Vm[1];
            xycoord=usf.coord_direction_update(Vm, xcoord, ycoord, nm_pts_vy, -nm_pts_vx, dt, nnum);
            xcoord = xycoord[0];   ycoord = xycoord[1];
    
            #update nucleus velocity based on F_sub;
            Fst_val = (Fsub_val[:nnum] - F_pro);
            V_nuc = T.nucleus_velocity(nm_pts_vx, nm_pts_vy, Fst_val, Force_ck[0], R_nuc_bar, eta_nuc_bar);

            xnuc_pst = xnuc_pst0 + dt*V_nuc[0] ;
            ynuc_pst = ynuc_pst0 + dt*V_nuc[1] ;

  
            nuc_mem_vx = xcoord[:nnum] - xnuc_pst;  # direction vectors of every membrane pts 
            nuc_mem_vy = ycoord[:nnum] - ynuc_pst;  # direction vectors from nucleus to membrane
            [nm_pts_vx, nm_pts_vy, R_len, Aa] = usf.Normalize_vector(nuc_mem_vx, nuc_mem_vy) #normalized position vectors
            #Area[i+1] = Aa;   
            disp = np.sqrt((xcoord-xcoord_tem)**2 + (ycoord-ycoord_tem)**2) ;
            xcoord_tem = xycoord[0];   ycoord_tem = xycoord[1];
            disp_tol = abs(np.sum(disp)); 

        edge_len = usf.edge_length(xcoord[0:nnum], ycoord[0:nnum]);

        f_all = usf.assign_values(fbond);

        Ro_all0 = usf.assign_values(Ro_all);
        xcoord0 = usf.assign_values(xcoord);
        ycoord0 = usf.assign_values(ycoord);
        xnuc_pst0 = usf.assign_scalar(xnuc_pst);
        ynuc_pst0 = usf.assign_scalar(ynuc_pst);
        Aa0 = usf.assign_scalar(Aa)

        if i%save_memb_inv < 1e-6:
            memb_step += 1; 
            xcoord_all[:, memb_step] = xycoord[0];    ycoord_all[:, memb_step] = xycoord[1];

        if i%save_nuc_inv < 1e-6:
            nuc_step += 1;
            Area[nuc_step] = Aa;
            time[nuc_step]= tm
            xnuc_all[nuc_step] = xnuc_pst;
            ynuc_all[nuc_step] = ynuc_pst;
 



    x_delta = xnuc_all[1:nuc_step] - xnuc_all[0:nuc_step-1];
    y_delta = ynuc_all[1:nuc_step] - ynuc_all[0:nuc_step-1];
    len_delta = np.sqrt((x_delta**2 + y_delta**2));
    traj_length = np.sum(len_delta)
    avg_vel = traj_length/time[nuc_step-1]


    Area_avg = np.mean(Area[int(nuc_step*0.5):nuc_step]);


    write_to_file_ary = np.array([np.amax(K_sub)*nnum/16, np.amax(gama_sub)*nnum/16, np.amax(Grad)*nnum/16,  avg_vel, \
                                      xnuc_all[0], xnuc_all[nuc_step-1], ynuc_all[0], ynuc_all[nuc_step-1]]);
                                      
    file1 = open("solution.txt", "a");  
    np.savetxt(file1, [write_to_file_ary],  fmt='%.6e', delimiter='\t');
    file1.close()  #.transpose()      .transpose(), newline=" " \n


    diffusion_str = 'diffusion model parameters \n'
    paramstring1='gama_r='+str(float(gama_r))+'; gama_rho='+str(float(gama_rho))+' \n'
    paramstring2='kb_plus='+str(float(kb_plus))+'; kb_minus='+str(float(kb_plus))+' \n'
    paramstring3='kpolar_minus='+str(float(kpolar_minus))+'; kap_polar_minus='+str(float(kap_polar_minus))+' \n'
    paramstring4='kapbb_plus='+str(float(kapbb_plus))+'; kapbb_minus='+str(float(kapbb_minus))+' \n'
    paramstring5='beta_r='+str(float(beta_r))+'; beta_r='+str(float(beta_r))+' \n'
    paramstring6='beta_rho='+str(float(beta_rho))+'; beta_rho='+str(float(beta_rho))+' \n'
    paramstring7='M_plus='+str(float(M_plus))+'; M_minus='+str(float(M_minus))+' \n'
    paramstring7='mu_plus='+str(float(mu_plus))+'; mu_minus='+str(float(mu_minus))+' \n'
    paramstring8='gg_val='+str(float(gg_val))+'; hh_val='+str(float(hh_val))+' \n'
    paramstring9='D='+str(float(D))+' \n'

    molecular_clutch_para = 'molecular clutch model parameters \n'
    paramstring10='alpha='+str(float(np.mean(alpha)))+'; epsilon='+str(float(epsilon))+' \n'
    paramstring11='kc='+str(float(kc))+'; ks='+str(float(ks))+' \n'
    paramstring12='fs='+str(float(fs))+'; fc='+str(float(fc))+' \n'
    paramstring13='K_clutch='+str(float(K_clutch))+'; fb='+str(float(fb))+' \n'

    mechanical_para = 'Mechanical parameters \n'
    paramstring14='K_sub='+str(float(np.mean(K_sub)))+'; gama_sub='+str(float(np.mean(gama_sub)))+' \n'
    paramstring15='K_memb='+str(float(np.mean(K_memb)))+'; eta_memb='+str(float(np.mean(eta_memb)))+' \n'
    paramstring16='K_ck='+str(float(np.mean(K_ck)))+'; K_Area='+str(float(np.mean(K_Area)))+' \n'


    filenameparam=fname+'_parameters_'+dd+'.txt'
    textfile=open(filenameparam, 'w')
    textfile.write(paramstring1+paramstring2+paramstring3+paramstring4+paramstring5+\
                       paramstring6+paramstring7+paramstring8+paramstring9+paramstring10 +\
                       paramstring11+paramstring12+paramstring13+paramstring14+paramstring15+paramstring16)
    textfile.close()


    filetarray=fname+'_tarray_'+dd+'.dat'
    #filemembX=fname+'_Xmemb_'+dd+'.dat'
    #filemembY=fname+'_Ymemb_'+dd+'.dat'
    filenucX=fname+'_Xnuc_'+dd+'.dat'
    filenucY=fname+'_Ynuc_'+dd+'.dat'
    


    np.savetxt(filetarray, time.transpose(),  fmt='%.6e', delimiter='\t');
    np.savetxt(filenucX, xnuc_all.transpose(),  fmt='%.6e', delimiter='\t');
    np.savetxt(filenucY, ynuc_all.transpose(),  fmt='%.6e', delimiter='\t');

    

    #pdb.set_trace()
    
    return fname    




uniform = int(0) ; # Durotaxis modeling 
duro = 3 ; 

nnum = int(16) ; 

Rac_cyto_tol = 1e-9 ; 

Grad = float(-0.86*16/nnum) ;

K_sub = float(5.7*16/nnum) ;

gama_sub = 0.000001*16/nnum;

dd_ary = ['01', '02', '03']    #, '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25'

dd_size = np.size(dd_ary)

for ii in range(dd_size):
    dd = dd_ary[ii];
    flog = migration_simulator(uniform, duro, K_sub, gama_sub, Grad, nnum, dd)


